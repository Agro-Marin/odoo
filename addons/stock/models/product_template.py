from collections import defaultdict
from dateutil.relativedelta import relativedelta

from odoo import _, api, fields, models
from odoo.exceptions import UserError
from odoo.tools import float_is_zero


class ProductTemplate(models.Model):
    _inherit = "product.template"
    _check_company_auto = True

    # ------------------------------------------------------------
    # FIELDS
    # ------------------------------------------------------------

    is_storable = fields.Boolean(
        string="Track Inventory",
        compute="compute_is_storable",
        store=True,
        precompute=True,
        readonly=False,
        default=False,
        help="A storable product is a product for which you manage stock.",
    )
    responsible_id = fields.Many2one(
        comodel_name="res.users",
        string="Responsible",
        default=lambda self: self.env.uid,
        company_dependent=True,
        check_company=True,
        help="This user will be responsible of the next activities related to logistic operations for this product.",
    )
    property_stock_production = fields.Many2one(
        comodel_name="stock.location",
        string="Production Location",
        company_dependent=True,
        check_company=True,
        domain="[('usage', '=', 'production'), '|', ('company_id', '=', False), ('company_id', '=', allowed_company_ids[0])]",
        help="This stock location will be used, instead of the default one, as the source location for stock moves generated by manufacturing orders.",
    )
    property_stock_inventory = fields.Many2one(
        "stock.location",
        "Inventory Location",
        company_dependent=True,
        check_company=True,
        domain="[('usage', '=', 'inventory'), '|', ('company_id', '=', False), ('company_id', '=', allowed_company_ids[0])]",
        help="This stock location will be used, instead of the default one, as the source location for stock moves generated when you do an inventory.",
    )
    # The goal of these fields is to be able to put some keys in context from search view in order
    # to influence computed field.
    location_id = fields.Many2one(
        "stock.location",
        "Location",
        store=False,
    )
    warehouse_id = fields.Many2one(
        "stock.warehouse",
        "Warehouse",
        store=False,
    )
    route_ids = fields.Many2many(
        "stock.route",
        "stock_route_product",
        "product_id",
        "route_id",
        "Routes",
        domain=[("product_selectable", "=", True)],
        depends_context=["company", "allowed_companies"],
        help="Depending on the modules installed, this will allow you to define the route of the product: whether it will be bought, manufactured, replenished on order, etc.",
    )
    tracking = fields.Selection(
        selection=[
            ("serial", "By Unique Serial Number"),
            ("lot", "By Lots"),
            ("none", "By Quantity"),
        ],
        string="Tracking",
        required=True,
        default="none",  # Not having a default value here causes issues when migrating.
        compute="_compute_tracking",
        store=True,
        precompute=True,
        readonly=False,
        help="Ensure the traceability of a storable product in your warehouse.",
    )
    description_picking = fields.Text(
        "Description on Picking",
        translate=True,
    )
    description_pickingout = fields.Text(
        "Description on Delivery Orders",
        translate=True,
    )
    description_pickingin = fields.Text(
        "Description on Receptions",
        translate=True,
    )
    sale_delay = fields.Integer(
        "Customer Lead Time",
        default=0,
        help="Delivery lead time, in days. It's the number of days, promised to the customer, between the confirmation of the sales order and the delivery.",
    )
    qty_available = fields.Float(
        "Quantity On Hand",
        compute="_compute_quantities",
        search="_search_qty_available",
        inverse="_inverse_qty_available",
        compute_sudo=False,
        digits="Product Unit",
    )
    virtual_available = fields.Float(
        "Forecasted Quantity",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        search="_search_virtual_available",
    )
    incoming_qty = fields.Float(
        "Incoming",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        search="_search_incoming_qty",
    )
    outgoing_qty = fields.Float(
        "Outgoing",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        search="_search_outgoing_qty",
    )
    nbr_moves_in = fields.Integer(
        compute="_compute_nbr_moves",
        compute_sudo=False,
        help="Number of incoming stock moves in the past 12 months",
    )
    nbr_moves_out = fields.Integer(
        compute="_compute_nbr_moves",
        compute_sudo=False,
        help="Number of outgoing stock moves in the past 12 months",
    )
    nbr_reordering_rules = fields.Integer(
        "Reordering Rules",
        compute="_compute_nbr_reordering_rules",
        compute_sudo=False,
    )
    reordering_min_qty = fields.Float(
        compute="_compute_nbr_reordering_rules",
        compute_sudo=False,
    )
    reordering_max_qty = fields.Float(
        compute="_compute_nbr_reordering_rules",
        compute_sudo=False,
    )
    # TDE FIXME: seems only visible in a view - remove me ?
    route_from_categ_ids = fields.Many2many(
        string="Category Routes",
        related="categ_id.total_route_ids",
        related_sudo=False,
    )
    has_available_route_ids = fields.Boolean(
        "Routes can be selected on this product",
        compute="_compute_has_available_route_ids",
        default=lambda self: self.env["stock.route"].search_count(
            [("product_selectable", "=", True)]
        ),
    )
    show_on_hand_qty_status_button = fields.Boolean(
        compute="_compute_show_qty_status_button"
    )
    show_forecasted_qty_status_button = fields.Boolean(
        compute="_compute_show_qty_status_button"
    )
    show_qty_update_button = fields.Boolean(
        compute="_compute_show_qty_update_button",
    )

    # ------------------------------------------------------------
    # CRUD METHODS
    # ------------------------------------------------------------

    @api.model_create_multi
    def create(self, vals_list):
        product_tmpl_quantities = [vals.pop("qty_available", 0) for vals in vals_list]

        product_templates = super().create(vals_list)

        if any(product_tmpl_quantities):
            for product_tmpl, qty in zip(product_templates, product_tmpl_quantities):
                if qty > 0 and product_tmpl.tracking == "none":
                    product_tmpl.product_variant_id.qty_available = qty

        return product_templates

    def write(self, vals):
        if "company_id" in vals and vals["company_id"]:
            products_changing_company = self.filtered(
                lambda product: product.company_id.id != vals["company_id"]
            )
            if products_changing_company:
                move = (
                    self.env["stock.move"]
                    .sudo()
                    .search(
                        [
                            (
                                "product_id",
                                "in",
                                products_changing_company.product_variant_ids.ids,
                            ),
                            ("company_id", "not in", [vals["company_id"], False]),
                        ],
                        order=None,
                        limit=1,
                    )
                )
                if move:
                    raise UserError(
                        _(
                            "This product's company cannot be changed as long as there are stock moves of it belonging to another company."
                        )
                    )

                # Forbid changing a product's company when quant(s) exist in another company.
                quant = (
                    self.env["stock.quant"]
                    .sudo()
                    .search(
                        [
                            (
                                "product_id",
                                "in",
                                products_changing_company.product_variant_ids.ids,
                            ),
                            ("company_id", "not in", [vals["company_id"], False]),
                            ("quantity", "!=", 0),
                        ],
                        order=None,
                        limit=1,
                    )
                )
                if quant:
                    raise UserError(
                        _(
                            "This product's company cannot be changed as long as there are quantities of it belonging to another company."
                        )
                    )

        if (
            "is_storable" in vals
            and not vals["is_storable"]
            and sum(self.mapped("nbr_reordering_rules")) != 0
        ):
            raise UserError(
                _(
                    "You still have some active reordering rules on this product. Please archive or delete them first."
                )
            )
        if any(
            "is_storable" in vals and vals["is_storable"] != prod_tmpl.is_storable
            for prod_tmpl in self
        ):
            existing_done_move_lines = (
                self.env["stock.move.line"]
                .sudo()
                .search(
                    [
                        (
                            "product_id",
                            "in",
                            self.with_context(active_test=False)
                            .mapped("product_variant_ids")
                            .ids,
                        ),
                        ("state", "=", "done"),
                    ],
                    limit=1,
                )
            )
            if existing_done_move_lines:
                raise UserError(
                    _(
                        "You can not change the inventory tracking of a product that was already used."
                    )
                )

            existing_reserved_move_lines = (
                self.env["stock.move.line"]
                .sudo()
                .search(
                    [
                        (
                            "product_id",
                            "in",
                            self.with_context(active_test=False)
                            .mapped("product_variant_ids")
                            .ids,
                        ),
                        ("state", "in", ["partially_available", "assigned"]),
                    ],
                    limit=1,
                )
            )
            if existing_reserved_move_lines:
                raise UserError(
                    _(
                        "You can not change the inventory tracking of a product that is currently reserved on a stock move. If you need to change the inventory tracking, you should first unreserve the stock move."
                    )
                )

        if (
            "is_storable" in vals
            and not vals["is_storable"]
            and any(
                p.is_storable
                and not float_is_zero(
                    p.qty_available, precision_rounding=p.uom_id.rounding
                )
                for p in self
            )
        ):
            raise UserError(
                _(
                    "Available quantity should be set to zero before changing inventory tracking"
                )
            )

        return super().write(vals)

    def copy(self, default=None):
        new_products = super().copy(default=default)
        # Since we don't copy product variants directly, we need to match the newly
        # created product variants with the old one, and copy the storage category
        # capacity from them.
        new_product_dict = {}
        for product in new_products.product_variant_ids:
            product_attribute_value = (
                product.product_template_attribute_value_ids.product_attribute_value_id
            )
            new_product_dict[product_attribute_value] = product.id
        storage_category_capacity_vals = []
        for (
            storage_category_capacity
        ) in self.product_variant_ids.storage_category_capacity_ids:
            product_attribute_value = (
                storage_category_capacity.product_id.product_template_attribute_value_ids.product_attribute_value_id
            )
            storage_category_capacity_vals.append(
                storage_category_capacity.copy_data(
                    {"product_id": new_product_dict[product_attribute_value]}
                )[0]
            )
        self.env["stock.storage.category.capacity"].create(
            storage_category_capacity_vals
        )
        return new_products

    # ------------------------------------------------------------
    # COMPUTE METHODS
    # ------------------------------------------------------------

    def _compute_nbr_moves(self):
        res = defaultdict(lambda: {"moves_in": 0, "moves_out": 0})
        incoming_moves = self.env["stock.move.line"]._read_group(
            [
                ("product_id.product_tmpl_id", "in", self.ids),
                ("state", "=", "done"),
                ("picking_code", "=", "incoming"),
                ("date", ">=", fields.Datetime.now() - relativedelta(years=1)),
            ],
            ["product_id"],
            ["__count"],
        )
        outgoing_moves = self.env["stock.move.line"]._read_group(
            [
                ("product_id.product_tmpl_id", "in", self.ids),
                ("state", "=", "done"),
                ("picking_code", "=", "outgoing"),
                ("date", ">=", fields.Datetime.now() - relativedelta(years=1)),
            ],
            ["product_id"],
            ["__count"],
        )
        for product, count in incoming_moves:
            product_tmpl_id = product.product_tmpl_id.id
            res[product_tmpl_id]["moves_in"] += count
        for product, count in outgoing_moves:
            product_tmpl_id = product.product_tmpl_id.id
            res[product_tmpl_id]["moves_out"] += count
        for template in self:
            template.nbr_moves_in = res[template.id]["moves_in"]
            template.nbr_moves_out = res[template.id]["moves_out"]

    def _compute_nbr_reordering_rules(self):
        res = {
            k: {
                "nbr_reordering_rules": 0,
                "reordering_min_qty": 0,
                "reordering_max_qty": 0,
            }
            for k in self.ids
        }
        product_data = self.env["stock.warehouse.orderpoint"]._read_group(
            [("product_id.product_tmpl_id", "in", self.ids)],
            ["product_id"],
            ["__count", "product_min_qty:sum", "product_max_qty:sum"],
        )
        for product, count, product_min_qty, product_max_qty in product_data:
            product_tmpl_id = product.product_tmpl_id.id
            res[product_tmpl_id]["nbr_reordering_rules"] += count
            res[product_tmpl_id]["reordering_min_qty"] = product_min_qty
            res[product_tmpl_id]["reordering_max_qty"] = product_max_qty
        for template in self:
            if not template.id:
                template.nbr_reordering_rules = 0
                template.reordering_min_qty = 0
                template.reordering_max_qty = 0
                continue
            template.nbr_reordering_rules = res[template.id]["nbr_reordering_rules"]
            template.reordering_min_qty = res[template.id]["reordering_min_qty"]
            template.reordering_max_qty = res[template.id]["reordering_max_qty"]

    @api.depends("type")
    def compute_is_storable(self):
        self.filtered(lambda t: t.type != "consu" and t.is_storable).is_storable = False

    @api.depends("is_storable")
    def _compute_tracking(self):
        self.filtered(lambda t: not t.is_storable and t.tracking != "none").tracking = (
            "none"
        )

    @api.depends("is_storable")
    def _compute_show_qty_status_button(self):
        for template in self:
            template.show_on_hand_qty_status_button = template.is_storable
            template.show_forecasted_qty_status_button = template.is_storable

    @api.depends("is_storable")
    def _compute_has_available_route_ids(self):
        self.has_available_route_ids = self.env["stock.route"].search_count(
            [("product_selectable", "=", True)]
        )

    @api.depends("count_product_variant", "tracking")
    def _compute_show_qty_update_button(self):
        for product in self:
            product.show_qty_update_button = (
                product._should_open_product_quants()
                or product.count_product_variant > 1
                or product.tracking != "none"
            )

    @api.depends_context("warehouse_id")
    @api.depends(
        "tracking",
        "product_variant_ids.qty_available",
        "product_variant_ids.virtual_available",
        "product_variant_ids.incoming_qty",
        "product_variant_ids.outgoing_qty",
    )
    def _compute_quantities(self):
        res = self._compute_quantities_dict()
        for template in self.with_context(skip_qty_available_update=True):
            template.qty_available = res[template.id]["qty_available"]
            template.virtual_available = res[template.id]["virtual_available"]
            template.incoming_qty = res[template.id]["incoming_qty"]
            template.outgoing_qty = res[template.id]["outgoing_qty"]

    # ------------------------------------------------------------
    # INVERSE METHODS
    # ------------------------------------------------------------

    def _inverse_qty_available(self):
        if self.env.context.get("skip_qty_available_update", False):
            return
        for template in self:
            if template.qty_available and not template.product_variant_id:
                raise UserError(
                    _("Save the product form before updating the Quantity On Hand.")
                )

            else:
                template.product_variant_id.qty_available = template.qty_available

    # ------------------------------------------------------------
    # SEARCH METHODS
    # ------------------------------------------------------------

    def _search_qty_available(self, operator, value):
        domain = [("qty_available", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    def _search_virtual_available(self, operator, value):
        domain = [("virtual_available", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    def _search_incoming_qty(self, operator, value):
        domain = [("incoming_qty", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    def _search_outgoing_qty(self, operator, value):
        domain = [("outgoing_qty", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    # ------------------------------------------------------------
    # ONCHANGE METHODS
    # ------------------------------------------------------------

    @api.onchange("tracking")
    def _onchange_tracking(self):
        return self.mapped("product_variant_ids")._onchange_tracking()

    @api.onchange("type")
    def _onchange_type(self):
        # Return a warning when trying to change the product type
        res = super()._onchange_type()
        if (
            self.ids
            and self.product_variant_ids.ids
            and self.env["stock.move.line"]
            .sudo()
            .search_count(
                [
                    ("product_id", "in", self.product_variant_ids.ids),
                    ("state", "!=", "cancel"),
                ]
            )
        ):
            res["warning"] = {
                "title": _("Warning!"),
                "message": _(
                    "This product has been used in at least one inventory movement. "
                    "It is not advised to change the Product Type since it can lead to inconsistencies. "
                    "A better solution could be to archive the product and create a new one instead."
                ),
            }
        return res

    # ------------------------------------------------------------
    # ACTIONS
    # ------------------------------------------------------------

    # Be aware that the exact same function exists in product.product
    def action_open_quants(self):
        if "product_variant" in self.env.context:
            return (
                self.env["product.product"]
                .browse(self.env.context["default_product_id"])
                .action_open_quants()
            )
        return self.product_variant_ids.filtered(
            lambda p: p.active or p.qty_available != 0
        ).action_open_quants()

    def action_view_related_putaway_rules(self):
        self.ensure_one()
        domain = [
            "|",
            ("product_id.product_tmpl_id", "=", self.id),
            ("category_id", "=", self.categ_id.id),
        ]
        return self._get_action_view_related_putaway_rules(domain)

    def action_view_storage_category_capacity(self):
        self.ensure_one()
        return self.product_variant_ids.action_view_storage_category_capacity()

    def action_view_orderpoints(self):
        return self.product_variant_ids.action_view_orderpoints()

    def action_view_stock_move_lines(self):
        self.ensure_one()
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.stock_move_line_action"
        )
        action["domain"] = [("product_id.product_tmpl_id", "in", self.ids)]
        return action

    def action_open_product_lot(self):
        self.ensure_one()
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.action_product_production_lot_form"
        )
        action["domain"] = [
            ("product_id.product_tmpl_id", "=", self.id),
            "|",
            ("location_id", "=", False),
            (
                "location_id",
                "any",
                self.env["stock.location"]._check_company_domain(
                    self._context["allowed_company_ids"]
                ),
            ),
        ]
        action["context"] = {
            "default_product_tmpl_id": self.id,
            "search_default_group_by_location": True,
        }
        if self.count_product_variant == 1:
            action["context"].update(
                {
                    "default_product_id": self.product_variant_id.id,
                }
            )
        return action

    def action_open_routes_diagram(self):
        products = False
        if self.env.context.get("default_product_id"):
            products = self.env["product.product"].browse(
                self.env.context["default_product_id"]
            )
        if not products and self.env.context.get("default_product_tmpl_id"):
            products = (
                self.env["product.template"]
                .browse(self.env.context["default_product_tmpl_id"])
                .product_variant_ids
            )
        if (
            not self.env.user.has_group("stock.group_stock_multi_warehouses")
            and len(products) == 1
        ):
            company = products.company_id or self.env.company
            warehouse = self.env["stock.warehouse"].search(
                [("company_id", "=", company.id)], limit=1
            )
            return self.env.ref("stock.action_report_stock_rule").report_action(
                None,
                data={
                    "product_id": products.id,
                    "warehouse_ids": warehouse.ids,
                },
                config=False,
            )
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.action_stock_rules_report"
        )
        action["context"] = self.env.context
        return action

    def action_product_tmpl_forecast_report(self):
        self.ensure_one()
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.stock_forecasted_product_template_action"
        )
        return action

    # ------------------------------------------------------------
    # HELPERS
    # ------------------------------------------------------------

    def _compute_quantities_dict(self):
        variants_available = {
            p["id"]: p
            for p in self.product_variant_ids._origin.read(
                ["qty_available", "virtual_available", "incoming_qty", "outgoing_qty"]
            )
        }
        prod_available = {}
        for template in self:
            qty_available = 0
            virtual_available = 0
            incoming_qty = 0
            outgoing_qty = 0
            for p in template.product_variant_ids._origin:
                qty_available += variants_available[p.id]["qty_available"]
                virtual_available += variants_available[p.id]["virtual_available"]
                incoming_qty += variants_available[p.id]["incoming_qty"]
                outgoing_qty += variants_available[p.id]["outgoing_qty"]
            prod_available[template.id] = {
                "qty_available": qty_available,
                "virtual_available": virtual_available,
                "incoming_qty": incoming_qty,
                "outgoing_qty": outgoing_qty,
            }
        return prod_available

    @api.model
    def _get_action_view_related_putaway_rules(self, domain):
        return {
            "name": _("Putaway Rules"),
            "type": "ir.actions.act_window",
            "res_model": "stock.putaway.rule",
            "view_mode": "list",
            "domain": domain,
        }

    # ------------------------------------------------------------
    # VALIDATIONS
    # ------------------------------------------------------------

    def _should_open_product_quants(self):
        self.ensure_one()
        advanced_option_groups = [
            "stock.group_stock_multi_locations",
            "stock.group_tracking_owner",
            "stock.group_tracking_lot",
        ]
        return (
            any(self.env.user.has_group(g) for g in advanced_option_groups)
            or self.tracking != "none"
        )
