from collections import defaultdict
from dateutil.relativedelta import relativedelta

from odoo import _, api, fields, models
from odoo.exceptions import UserError


SERIAL_PREFIX_FORMAT_HELP_TEXT = """
    If multiple products share the same prefix, they will share the same sequence, otherwise the sequence will be dedicated to the product.

    * Legend (for prefix):
    - Current Year with Century: %(year)s
    - Current Year without Century: %(y)s
    - Month: %(month)s
    - Day: %(day)s
    - Day of the Year: %(doy)s
    - Week of the Year: %(woy)s
    - Day of the Week (0:Monday): %(weekday)s
    - Hour 00->24: %(h24)s
    - Hour 00->12: %(h12)s
    - Minute: %(min)s
    - Second: %(sec)s
"""


class ProductTemplate(models.Model):
    _inherit = "product.template"
    _check_company_auto = True

    is_storable = fields.Boolean(
        string="Track Inventory",
        default=False,
        compute="compute_is_storable",
        store=True,
        precompute=True,
        readonly=False,
        tracking=True,
        help="A storable product is a product for which you manage stock.",
    )
    responsible_id = fields.Many2one(
        comodel_name="res.users",
        string="Responsible",
        default=lambda self: self._default_responsible_id(),
        company_dependent=True,
        check_company=True,
        help="This user will be responsible of the next activities related to logistic operations for this product.",
    )
    property_stock_production = fields.Many2one(
        comodel_name="stock.location",
        string="Production Location",
        company_dependent=True,
        check_company=True,
        domain="[('usage', '=', 'production'), ('company_id', 'in', [False, allowed_company_ids[0]])]",
        help="This stock location will be used, instead of the default one, as the source location for stock moves generated by manufacturing orders.",
    )
    property_stock_inventory = fields.Many2one(
        comodel_name="stock.location",
        string="Inventory Location",
        company_dependent=True,
        check_company=True,
        domain="[('usage', '=', 'inventory'), ('company_id', 'in', [False, allowed_company_ids[0]])]",
        help="This stock location will be used, instead of the default one, as the source location for stock moves generated when you do an inventory.",
    )
    sale_delay = fields.Integer(
        string="Customer Lead Time",
        default=0,
        help="Delivery lead time, in days. It's the number of days, promised to the customer, between the confirmation of the sales order and the delivery.",
    )
    tracking = fields.Selection(
        selection=[
            ("serial", "By Unique Serial Number"),
            ("lot", "By Lots"),
            ("none", "By Quantity"),
        ],
        string="Tracking",
        required=True,
        default="none",
        compute="_compute_tracking",
        store=True,
        precompute=True,
        readonly=False,
        # Not having a default value here causes issues when migrating.
        help="Ensure the traceability of a storable product in your warehouse.",
    )
    lot_sequence_id = fields.Many2one(
        comodel_name="ir.sequence",
        string="Serial/Lot Numbers Sequence",
        default=lambda self: self.env.ref(
            "stock.sequence_production_lots",
            raise_if_not_found=False,
        ),
        help="Technical Field: The Ir.Sequence record that is used to generate serial/lot numbers for this product",
    )
    serial_prefix_format = fields.Char(
        string="Custom Lot/Serial",
        compute="_compute_serial_prefix_format",
        inverse="_inverse_serial_prefix_format",
        help=SERIAL_PREFIX_FORMAT_HELP_TEXT,
    )
    next_serial = fields.Char(compute="_compute_next_serial")
    description_picking = fields.Text(string="Description on Picking", translate=True)
    description_pickingout = fields.Text(
        string="Description on Delivery Orders",
        translate=True,
    )
    description_pickingin = fields.Text(
        string="Description on Receptions",
        translate=True,
    )
    qty_available = fields.Float(
        string="Quantity On Hand",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        inverse="_inverse_qty_available",
        search="_search_qty_available",
    )
    virtual_available = fields.Float(
        string="Forecasted Quantity",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        search="_search_virtual_available",
    )
    incoming_qty = fields.Float(
        string="Incoming",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        search="_search_incoming_qty",
    )
    outgoing_qty = fields.Float(
        string="Outgoing",
        digits="Product Unit",
        compute="_compute_quantities",
        compute_sudo=False,
        search="_search_outgoing_qty",
    )
    # The goal of these fields is to be able to put some keys in context from search view in order
    # to influence computed field.
    location_id = fields.Many2one(
        comodel_name="stock.location",
        string="Location",
        store=False,
    )
    warehouse_id = fields.Many2one(
        comodel_name="stock.warehouse",
        string="Warehouse",
        store=False,
    )
    has_available_route_ids = fields.Boolean(
        string="Routes can be selected on this product",
        default=lambda self: self.env["stock.route"].search_count(
            [("product_selectable", "=", True)]
        ),
        compute="_compute_has_available_route_ids",
    )
    route_ids = fields.Many2many(
        comodel_name="stock.route",
        relation="stock_route_product",
        column1="product_id",
        column2="route_id",
        string="Routes",
        domain=[("product_selectable", "=", True)],
        help="Depending on the modules installed, this will allow you to define the route of the product: whether it will be bought, manufactured, replenished on order, etc.",
        depends_context=["company", "allowed_companies"],
    )
    nbr_moves_in = fields.Integer(
        compute="_compute_nbr_moves",
        compute_sudo=False,
        help="Number of incoming stock moves in the past 12 months",
    )
    nbr_moves_out = fields.Integer(
        compute="_compute_nbr_moves",
        compute_sudo=False,
        help="Number of outgoing stock moves in the past 12 months",
    )
    nbr_reordering_rules = fields.Integer(
        string="Reordering Rules",
        compute="_compute_nbr_reordering_rules",
        compute_sudo=False,
    )
    reordering_min_qty = fields.Float(
        compute="_compute_nbr_reordering_rules",
        compute_sudo=False,
    )
    reordering_max_qty = fields.Float(
        compute="_compute_nbr_reordering_rules",
        compute_sudo=False,
    )
    # TDE FIXME: seems only visible in a view - remove me ?
    route_from_categ_ids = fields.Many2many(
        related="categ_id.total_route_ids",
        string="Category Routes",
        related_sudo=False,
    )
    show_on_hand_qty_status_button = fields.Boolean(
        compute="_compute_show_qty_status_button"
    )
    show_forecasted_qty_status_button = fields.Boolean(
        compute="_compute_show_qty_status_button"
    )
    show_qty_update_button = fields.Boolean(compute="_compute_show_qty_update_button")

    @api.model_create_multi
    def create(self, vals_list):
        product_tmpl_quantities = [vals.pop("qty_available", 0) for vals in vals_list]

        product_templates = super().create(vals_list)

        if any(product_tmpl_quantities):
            for product_tmpl, qty in zip(product_templates, product_tmpl_quantities):
                if qty > 0 and product_tmpl.tracking == "none":
                    product_tmpl.product_variant_id.qty_available = qty
        return product_templates

    def write(self, vals):
        if "company_id" in vals and vals["company_id"]:
            products_changing_company = self.filtered(
                lambda product: product.company_id.id != vals["company_id"],
            )
            if products_changing_company:
                move = (
                    self.env["stock.move"]
                    .sudo()
                    .search(
                        [
                            (
                                "product_id",
                                "in",
                                products_changing_company.product_variant_ids.ids,
                            ),
                            ("company_id", "not in", [vals["company_id"], False]),
                        ],
                        order=None,
                        limit=1,
                    )
                )
                if move:
                    raise UserError(
                        _(
                            "This product's company cannot be changed as long as there are stock moves of it belonging to another company.",
                        ),
                    )

                # Forbid changing a product's company when quant(s) exist in another company.
                quant = (
                    self.env["stock.quant"]
                    .sudo()
                    .search(
                        [
                            (
                                "product_id",
                                "in",
                                products_changing_company.product_variant_ids.ids,
                            ),
                            ("company_id", "not in", [vals["company_id"], False]),
                            ("quantity", "!=", 0),
                        ],
                        order=None,
                        limit=1,
                    )
                )
                if quant:
                    raise UserError(
                        _(
                            "This product's company cannot be changed as long as there are quantities of it belonging to another company.",
                        ),
                    )

        clean_inventory = False
        if "is_storable" in vals and any(
            vals["is_storable"] != prod_tmpl.is_storable and not prod_tmpl.is_storable
            for prod_tmpl in self
        ):
            clean_inventory = True

        res = super().write(vals)
        if clean_inventory:
            self.env["stock.quant"].sudo()._clean_reservations()
        return res

    def copy(self, default=None):
        new_products = super().copy(default=default)
        # Since we don't copy product variants directly, we need to match the newly
        # created product variants with the old one, and copy the storage category
        # capacity from them.
        new_product_dict = {}
        for product in new_products.product_variant_ids:
            product_attribute_value = (
                product.product_template_attribute_value_ids.product_attribute_value_id
            )
            new_product_dict[product_attribute_value] = product.id
        storage_category_capacity_vals = []
        for (
            storage_category_capacity
        ) in self.product_variant_ids.storage_category_capacity_ids:
            product_attribute_value = (
                storage_category_capacity.product_id.product_template_attribute_value_ids.product_attribute_value_id
            )
            storage_category_capacity_vals.append(
                storage_category_capacity.copy_data(
                    {"product_id": new_product_dict[product_attribute_value]},
                )[0],
            )
        self.env["stock.storage.category.capacity"].create(
            storage_category_capacity_vals,
        )
        return new_products

    def _compute_nbr_reordering_rules(self):
        res = {
            k: {
                "nbr_reordering_rules": 0,
                "reordering_min_qty": 0,
                "reordering_max_qty": 0,
            }
            for k in self.ids
        }
        product_data = self.env["stock.warehouse.orderpoint"]._read_group(
            [("product_id.product_tmpl_id", "in", self.ids)],
            ["product_id"],
            ["__count", "product_min_qty:sum", "product_max_qty:sum"],
        )
        for product, count, product_min_qty, product_max_qty in product_data:
            product_tmpl_id = product.product_tmpl_id.id
            res[product_tmpl_id]["nbr_reordering_rules"] += count
            res[product_tmpl_id]["reordering_min_qty"] = product_min_qty
            res[product_tmpl_id]["reordering_max_qty"] = product_max_qty
        for template in self:
            if not template.id:
                template.nbr_reordering_rules = 0
                template.reordering_min_qty = 0
                template.reordering_max_qty = 0
                continue
            template.nbr_reordering_rules = res[template.id]["nbr_reordering_rules"]
            template.reordering_min_qty = res[template.id]["reordering_min_qty"]
            template.reordering_max_qty = res[template.id]["reordering_max_qty"]

    @api.depends("type")
    def compute_is_storable(self):
        self.filtered(lambda t: t.type != "consu" and t.is_storable).is_storable = False

    @api.depends("is_storable")
    def _compute_tracking(self):
        self.filtered(lambda t: not t.is_storable and t.tracking != "none").tracking = (
            "none"
        )

    @api.depends("lot_sequence_id", "lot_sequence_id.prefix")
    def _compute_serial_prefix_format(self):
        for template in self:
            template.serial_prefix_format = template.lot_sequence_id.prefix or ""

    @api.depends("serial_prefix_format", "lot_sequence_id")
    def _compute_next_serial(self):
        for template in self:
            if template.lot_sequence_id:
                template.next_serial = "{:0{}d}{}".format(
                    template.lot_sequence_id.number_next_actual,
                    template.lot_sequence_id.padding,
                    template.lot_sequence_id.suffix or "",
                )
            else:
                template.next_serial = "0000001"

    @api.depends("is_storable")
    def _compute_show_qty_status_button(self):
        for template in self:
            template.show_on_hand_qty_status_button = template.is_storable
            template.show_forecasted_qty_status_button = template.is_storable

    @api.depends("is_storable")
    def _compute_has_available_route_ids(self):
        self.has_available_route_ids = self.env["stock.route"].search_count(
            [("product_selectable", "=", True)],
        )

    @api.depends("product_variant_count", "tracking")
    def _compute_show_qty_update_button(self):
        for product in self:
            product.show_qty_update_button = (
                product._should_open_product_quants()
                or product.product_variant_count > 1
            )

    @api.depends(
        "product_variant_ids.qty_available",
        "product_variant_ids.virtual_available",
        "product_variant_ids.incoming_qty",
        "product_variant_ids.outgoing_qty",
        "tracking",
    )
    @api.depends_context("warehouse_id")
    def _compute_quantities(self):
        res = self._compute_quantities_dict()
        for template in self.with_context(skip_qty_available_update=True):
            template.qty_available = res[template.id]["qty_available"]
            template.virtual_available = res[template.id]["virtual_available"]
            template.incoming_qty = res[template.id]["incoming_qty"]
            template.outgoing_qty = res[template.id]["outgoing_qty"]

    def _compute_quantities_dict(self):
        variants_available = {
            p["id"]: p
            for p in self.product_variant_ids._origin.read(
                ["qty_available", "virtual_available", "incoming_qty", "outgoing_qty"],
            )
        }
        prod_available = {}
        for template in self:
            qty_available = 0
            virtual_available = 0
            incoming_qty = 0
            outgoing_qty = 0
            for p in template.product_variant_ids._origin:
                qty_available += variants_available[p.id]["qty_available"]
                virtual_available += variants_available[p.id]["virtual_available"]
                incoming_qty += variants_available[p.id]["incoming_qty"]
                outgoing_qty += variants_available[p.id]["outgoing_qty"]
            prod_available[template.id] = {
                "qty_available": qty_available,
                "virtual_available": virtual_available,
                "incoming_qty": incoming_qty,
                "outgoing_qty": outgoing_qty,
            }
        return prod_available

    def _compute_nbr_moves(self):
        res = defaultdict(lambda: {"moves_in": 0, "moves_out": 0})
        incoming_moves = self.env["stock.move.line"]._read_group(
            [
                ("product_id.product_tmpl_id", "in", self.ids),
                ("state", "=", "done"),
                ("picking_code", "=", "incoming"),
                ("date", ">=", fields.Datetime.now() - relativedelta(years=1)),
            ],
            ["product_id"],
            ["__count"],
        )
        outgoing_moves = self.env["stock.move.line"]._read_group(
            [
                ("product_id.product_tmpl_id", "in", self.ids),
                ("state", "=", "done"),
                ("picking_code", "=", "outgoing"),
                ("date", ">=", fields.Datetime.now() - relativedelta(years=1)),
            ],
            ["product_id"],
            ["__count"],
        )
        for product, count in incoming_moves:
            product_tmpl_id = product.product_tmpl_id.id
            res[product_tmpl_id]["moves_in"] += count
        for product, count in outgoing_moves:
            product_tmpl_id = product.product_tmpl_id.id
            res[product_tmpl_id]["moves_out"] += count
        for template in self:
            template.nbr_moves_in = res[template.id]["moves_in"]
            template.nbr_moves_out = res[template.id]["moves_out"]

    def _inverse_serial_prefix_format(self):
        valid_sequences = self.env["ir.sequence"].search(
            [("prefix", "in", self.mapped("serial_prefix_format"))],
        )
        sequences_by_prefix = {seq.prefix: seq for seq in valid_sequences}
        for template in self:
            if template.serial_prefix_format:
                if template.serial_prefix_format in sequences_by_prefix:
                    template.lot_sequence_id = sequences_by_prefix[
                        template.serial_prefix_format
                    ]
                else:
                    new_sequence = self.env["ir.sequence"].create(
                        {
                            "name": f"{template.name} Serial Sequence",
                            "code": "stock.lot.serial",
                            "prefix": template.serial_prefix_format,
                            "padding": 7,
                            "company_id": False,
                        },
                    )
                    template.lot_sequence_id = new_sequence
                    sequences_by_prefix[template.serial_prefix_format] = new_sequence
            else:
                template.lot_sequence_id = self.env.ref(
                    "stock.sequence_production_lots",
                    raise_if_not_found=False,
                )

    def _inverse_qty_available(self):
        if self.env.context.get("skip_qty_available_update", False):
            return
        for template in self:
            if template.qty_available and not template.product_variant_id:
                raise UserError(
                    _("Save the product form before updating the Quantity On Hand."),
                )
            else:
                template.product_variant_id.qty_available = template.qty_available

    def _search_qty_available(self, operator, value):
        domain = [("qty_available", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    def _search_virtual_available(self, operator, value):
        domain = [("virtual_available", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    def _search_incoming_qty(self, operator, value):
        domain = [("incoming_qty", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    def _search_outgoing_qty(self, operator, value):
        domain = [("outgoing_qty", operator, value)]
        product_variant_query = self.env["product.product"]._search(domain)
        return [("product_variant_ids", "in", product_variant_query)]

    @api.onchange("tracking")
    def _onchange_tracking(self):
        return self.mapped("product_variant_ids")._onchange_tracking()

    @api.onchange("type")
    def _onchange_type(self):
        # Return a warning when trying to change the product type
        res = super()._onchange_type()
        if (
            self.ids
            and self.product_variant_ids.ids
            and self.env["stock.move.line"]
            .sudo()
            .search_count(
                [
                    ("product_id", "in", self.product_variant_ids.ids),
                    ("state", "!=", "cancel"),
                ],
            )
        ):
            res["warning"] = {
                "title": _("Warning!"),
                "message": _(
                    "This product has been used in at least one inventory movement. "
                    "It is not advised to change the Product Type since it can lead to inconsistencies. "
                    "A better solution could be to archive the product and create a new one instead."
                ),
            }
        return res

    # Be aware that the exact same function exists in product.product
    def action_open_quants(self):
        if "product_variant" in self.env.context:
            return (
                self.env["product.product"]
                .browse(self.env.context["default_product_id"])
                .action_open_quants()
            )
        return self.product_variant_ids.filtered(
            lambda p: p.active or p.qty_available != 0,
        ).action_open_quants()

    def action_view_related_putaway_rules(self):
        self.ensure_one()
        domain = [
            "|",
            ("product_id.product_tmpl_id", "=", self.id),
            ("category_id", "=", self.categ_id.id),
        ]
        return self._get_action_view_related_putaway_rules(domain)

    def action_view_storage_category_capacity(self):
        self.ensure_one()
        return self.product_variant_ids.action_view_storage_category_capacity()

    def action_view_orderpoints(self):
        return self.product_variant_ids.action_view_orderpoints()

    def action_view_stock_move_lines(self):
        self.ensure_one()
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.stock_move_line_action",
        )
        action["domain"] = [("product_id.product_tmpl_id", "in", self.ids)]
        return action

    def action_open_product_lot(self):
        self.ensure_one()
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.action_product_production_lot_form",
        )
        action["domain"] = [
            ("product_id.product_tmpl_id", "=", self.id),
            "|",
            ("location_id", "=", False),
            (
                "location_id",
                "any",
                self.env["stock.location"]._check_company_domain(
                    self.env.context["allowed_company_ids"]
                ),
            ),
        ]
        action["context"] = {
            "default_product_tmpl_id": self.id,
            "search_default_group_by_location": True,
        }
        if self.product_variant_count == 1:
            action["context"].update(
                {
                    "default_product_id": self.product_variant_id.id,
                },
            )
        return action

    def action_open_routes_diagram(self):
        products = False
        if self.env.context.get("default_product_id"):
            products = self.env["product.product"].browse(
                self.env.context["default_product_id"]
            )
        if not products and self.env.context.get("default_product_tmpl_id"):
            products = (
                self.env["product.template"]
                .browse(self.env.context["default_product_tmpl_id"])
                .product_variant_ids
            )
        if (
            not self.env.user.has_group("stock.group_stock_multi_warehouses")
            and len(products) == 1
        ):
            company = products.company_id or self.env.company
            warehouse = self.env["stock.warehouse"].search(
                [("company_id", "=", company.id)],
                limit=1,
            )
            return self.env.ref("stock.action_report_stock_rule").report_action(
                None,
                data={
                    "product_id": products.id,
                    "warehouse_ids": warehouse.ids,
                },
                config=False,
            )
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.action_stock_rules_report",
        )
        action["context"] = self.env.context
        return action

    def action_product_tmpl_forecast_report(self):
        self.ensure_one()
        if not self.env.user._get_default_warehouse_id():
            self.env["stock.warehouse"]._warehouse_redirect_warning()
        action = self.env["ir.actions.actions"]._for_xml_id(
            "stock.stock_forecasted_product_template_action",
        )
        return action

    @api.model
    def _get_action_view_related_putaway_rules(self, domain):
        return {
            "name": _("Putaway Rules"),
            "type": "ir.actions.act_window",
            "res_model": "stock.putaway.rule",
            "view_mode": "list",
            "domain": domain,
        }

    def _default_responsible_id(self):
        # Return the current user unless it's OdooBot
        return not self.env.user._is_superuser() and self.env.uid

    def _should_open_product_quants(self):
        self.ensure_one()
        advanced_option_groups = [
            "stock.group_stock_multi_locations",
            "stock.group_tracking_owner",
            "stock.group_tracking_lot",
        ]
        return (
            any(self.env.user.has_group(g) for g in advanced_option_groups)
            or self.tracking != "none"
        )
